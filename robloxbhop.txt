local player = game.Players.LocalPlayer
local cam = workspace.CurrentCamera
local UIS = game:GetService("UserInputService")
local hb = game:GetService("RunService").Heartbeat
local rs = game:GetService("RunService")
local tpwalking = false

local originalFOV = cam.FieldOfView
local originalWalkSpeed = 16

----------------------------------------------------------------
-- ARM VISIBILITY (your reference code)
----------------------------------------------------------------

local function antiTrans(part)
	if part and part:IsA("BasePart") and (part.Name == "Left Arm" or part.Name == "Right Arm") then
		part.LocalTransparencyModifier = part.Transparency

		part.Changed:Connect(function(property)
			if property == "Transparency" or property == "LocalTransparencyModifier" then
				part.LocalTransparencyModifier = part.Transparency
			end
		end)
	end
end

----------------------------------------------------------------
-- TPWALK FUNCTION
----------------------------------------------------------------
local tpwalking = false
local tpwalkSpeed = 0 -- starting speed
local maxTPWalk = 77
local landingTime = 0
local jumpAfterLanding = false

local function startTPWalk(char, hum)
	tpwalking = true
	task.spawn(function()
	local wasOnGround = hum.FloorMaterial ~= Enum.Material.Air
		while tpwalking and char and hum and hum.Parent do
			local delta = game:GetService("RunService").Heartbeat:Wait()
			local onGround = hum.FloorMaterial ~= Enum.Material.Air
			
			-- detect landing
    		if onGround and not wasOnGround then
        		landingTime = tick()
        		jumpAfterLanding = false
    		end

    		-- 0.5s window to jump again
    		if onGround and (tick() - landingTime) >= 0.3 and not jumpAfterLanding then
        		tpwalkSpeed = 0
    		end

			-- increase speed only if jumping
			if hum:GetState() == Enum.HumanoidStateType.Jumping then
				tpwalkSpeed = math.clamp(tpwalkSpeed + 0.3, 0.3, maxTPWalk)
			end

			if hum.MoveDirection.Magnitude > 0 then
				char:TranslateBy(hum.MoveDirection * tpwalkSpeed * delta * 10)
			end

			wasOnGround = onGround
		end
	end)
end

local function stopTPWalk()
	tpwalking = false
	tpwalkSpeed = 0 -- reset speed on stop
end

-- reset tpwalk when R is pressed
UIS.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.R then
		tpwalkSpeed = 0
	end
end)

----------------------------------------------------------------
-- EVERYTHING ELSE IDFK
----------------------------------------------------------------
local function setupCharacter(char)
	local hum = char:WaitForChild("Humanoid")

	-- store original walkspeed
	originalWalkSpeed = hum.WalkSpeed

	-- apply new walkspeed
	hum.WalkSpeed = 17

	-- apply arms anti-transparency
	for _,v in ipairs(char:GetChildren()) do
		antiTrans(v)
	end
	char.ChildAdded:Connect(antiTrans)

	-- gravity settings
	workspace.Gravity = 160

	-- create TPWalk counter GUI
	local playerGui = player:WaitForChild("PlayerGui")
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "TPWalkCounter"
	screenGui.Parent = playerGui
	screenGui.ResetOnSpawn = false

	local counterLabel = Instance.new("TextLabel")
	counterLabel.Size = UDim2.new(0, 100, 0, 50)
	counterLabel.Position = UDim2.new(0.5, -50, 0, 50) -- start near top center
	counterLabel.BackgroundTransparency = 1
	counterLabel.TextColor3 = Color3.new(1, 1, 1) -- white
	counterLabel.Font = Enum.Font.SciFi
	counterLabel.TextScaled = true
	counterLabel.Text = tostring(math.floor(tpwalkSpeed))
	counterLabel.Active = true
	counterLabel.Draggable = true
	counterLabel.Parent = screenGui

local lastPos = nil
local lastUpdate = tick()

game:GetService("RunService").RenderStepped:Connect(function()
    if not counterLabel then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local now = tick()

    -- only update every 0.5s
    if now - lastUpdate >= 0.05 then
        if lastPos == nil then
            lastPos = hrp.Position
            lastUpdate = now
            return
        end

        local dt = now - lastUpdate
        local dist = hrp.Position - lastPos
        local horizontal = Vector3.new(dist.X, 0, dist.Z).Magnitude / dt

        counterLabel.Text = string.format("%.1f", horizontal)

        -- store for next cycle
        lastPos = hrp.Position
        lastUpdate = now
    end
end)


	-- start tpwalk (speed = 20)
	startTPWalk(char, hum)
end

----------------------------------------------------------------
-- reset character = reset tpwalk haha everythings stays
----------------------------------------------------------------
local function cleanup()
	stopTPWalk()

	-- reset camera
	cam.FieldOfView = originalFOV
end

player.CharacterRemoving:Connect(cleanup)
player.CharacterAdded:Connect(setupCharacter)

if player.Character then
	setupCharacter(player.Character)
end

local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function setupCharacter(char)
	local humanoid = char:WaitForChild("Humanoid")

	-- create animation
	local anim = Instance.new("Animation")
	anim.AnimationId = "rbxassetid://287325678"

	local track = humanoid:LoadAnimation(anim)
	track.Priority = Enum.AnimationPriority.Action4

	-- function to handle delayed jump check
	local function delayedJumpCheck()
		task.wait(0.6)
		if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
			if track.IsPlaying then
				track:Stop()
			end
		end
	end

	local function onStateChanged(_, newState)
		if newState == Enum.HumanoidStateType.Jumping then
			if not track.IsPlaying then
				track:Play()
			end
			task.spawn(delayedJumpCheck)

		elseif newState == Enum.HumanoidStateType.FallingDown then
			if track.IsPlaying then
				track:Stop()
			end
		end
	end

	humanoid.StateChanged:Connect(onStateChanged)

	-- cleanup on reset
	char.AncestryChanged:Connect(function(_, parent)
		if not parent then
			if track.IsPlaying then
				track:Stop()
			end
			track:Destroy()
			anim:Destroy()
		end
	end)
end

player.CharacterAdded:Connect(setupCharacter)
if player.Character then
	setupCharacter(player.Character)
end
