-- CUSTOM MOVEMENT: PC + Mobile, Half-Life style air control, baseSpeed 17
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local plr = Players.LocalPlayer
repeat RunService.RenderStepped:Wait() until plr
local char = plr.Character or plr.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local hum = char:WaitForChild("Humanoid")

hum.PlatformStand = true -- disable default humanoid movement

-- movement settings
local baseSpeed = 17
local speedCap = 100
local decelRate = 50
local lowFriction = 0.7
local currSpeed = baseSpeed
local gravity = -196.2

local origProps = hrp.CustomPhysicalProperties or PhysicalProperties.new(0.7,0.3,0.5,1,1)
local slipProps = PhysicalProperties.new(origProps.Density, lowFriction, origProps.Elasticity,100,origProps.ElasticityWeight)

-- state
local velocity = Vector3.zero
local kbInput = Vector3.zero
local lastDir = Vector3.new(0,0,0)
local sliding = false
local grounded = false

-- helper: ground check
local function checkGround()
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {char}
	params.FilterType = Enum.RaycastFilterType.Blacklist
	local result = Workspace:Raycast(hrp.Position, Vector3.new(0,-3.5,0), params)
	return result and true or false
end

-- keyboard input
UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == Enum.KeyCode.W then kbInput += Vector3.new(0,0,-1) end
	if input.KeyCode == Enum.KeyCode.S then kbInput += Vector3.new(0,0,1) end
	if input.KeyCode == Enum.KeyCode.A then kbInput += Vector3.new(-1,0,0) end
	if input.KeyCode == Enum.KeyCode.D then kbInput += Vector3.new(1,0,0) end
end)
UserInputService.InputEnded:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == Enum.KeyCode.W then kbInput -= Vector3.new(0,0,-1) end
	if input.KeyCode == Enum.KeyCode.S then kbInput -= Vector3.new(0,0,1) end
	if input.KeyCode == Enum.KeyCode.A then kbInput -= Vector3.new(-1,0,0) end
	if input.KeyCode == Enum.KeyCode.D then kbInput -= Vector3.new(1,0,0) end
end)

-- jump input
hum.Jumping:Connect(function()
	if grounded then
		velocity = Vector3.new(velocity.X, hum.JumpPower, velocity.Z)
	end
end)

-- main loop
RunService.Heartbeat:Connect(function(dt)
	grounded = checkGround()

	-- get input direction (keyboard preferred, else MoveDirection for mobile)
	local moveDir = Vector3.zero
	if kbInput.Magnitude > 0 then
		local cam = Workspace.CurrentCamera
		if cam then
			local camForward = Vector3.new(cam.CFrame.LookVector.X, 0, cam.CFrame.LookVector.Z).Unit
			local camRight = Vector3.new(cam.CFrame.RightVector.X, 0, cam.CFrame.RightVector.Z).Unit
			moveDir = (camRight * kbInput.X + camForward * kbInput.Z)
			if moveDir.Magnitude > 0 then moveDir = moveDir.Unit end
		end
	else
		local md = plr.MoveDirection
		if md.Magnitude > 0 then moveDir = Vector3.new(md.X,0,md.Z).Unit end
	end

	-- AIR CONTROL: instant horizontal steering
	local hzVel = Vector3.new(velocity.X,0,velocity.Z)
	if not grounded and moveDir.Magnitude > 0 and hzVel.Magnitude > 0 then
		hzVel = moveDir * hzVel.Magnitude
	end

	-- GROUND CONTROL
	if grounded then
		if moveDir.Magnitude > 0 then
			hzVel = moveDir * currSpeed
			lastDir = moveDir
			sliding = false
			hrp.CustomPhysicalProperties = origProps
		else
			if currSpeed > baseSpeed then
				if not sliding then
					sliding = true
					hrp.CustomPhysicalProperties = slipProps
					hzVel = lastDir * currSpeed
				end
				currSpeed = math.max(baseSpeed, currSpeed - decelRate*dt)
				if hzVel.Magnitude > 0 then
					hzVel = hzVel.Unit * currSpeed
				end
				if currSpeed <= baseSpeed then
					sliding = false
					hrp.CustomPhysicalProperties = origProps
				end
			else
				sliding = false
				hrp.CustomPhysicalProperties = origProps
				hzVel = Vector3.zero
				currSpeed = baseSpeed
			end
		end
	end

	-- apply horizontal velocity
	velocity = Vector3.new(hzVel.X, velocity.Y, hzVel.Z)

	-- apply gravity
	if not grounded then
		velocity += Vector3.new(0, gravity * dt, 0)
	else
		velocity = Vector3.new(velocity.X,0,velocity.Z)
	end

	-- move HRP while preventing falling through floor
	local newPos = hrp.Position + velocity*dt
	local ray = Workspace:Raycast(newPos, Vector3.new(0,-3.5,0), RaycastParams.new())
	if ray then
		-- snap to floor if close
		if newPos.Y < ray.Position.Y + 2 then
			newPos = Vector3.new(newPos.X, ray.Position.Y + 2, newPos.Z)
			velocity = Vector3.new(velocity.X,0,velocity.Z)
		end
	end

	hrp.CFrame = CFrame.new(newPos)
end)
